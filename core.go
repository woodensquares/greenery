package greenery

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"os/signal"
	"reflect"
	"runtime"
	"sort"
	"strings"
	"syscall"
	"text/template"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/davecgh/go-spew/spew"
	"github.com/spf13/afero"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/woodensquares/greenery/internal/doc"
)

// Config is FIXME:DOC
type Config interface {
	Cleanup()
	Dump(Config) (string, error)
	Execute(Config, map[string]*DocSet) error
	GetConfigFile() string
	GetCurrentCommand() string
	GetDefaultLanguage() string
	GetDocs() (string, *DocSet)
	GetFs() afero.Fs
	RegisterExtraParse(func(Config, map[string]interface{}) ([]string, error), []string)
	SetFs(afero.Fs)
	SetHandler(string, Handler) error
	SetOptions(BaseConfigOptions) error
	GetLogger() Logger
	SetLoggers(MakeLogger, MakeLogger, MakeTraceLogger) error
	Unmarshal(string, interface{}) error

	Debugq(string)
	Debugqf(string, ...interface{})
	Debugqs(string, ...LogField)
	Debug(string)
	Debugf(string, ...interface{})
	Debugs(string, ...LogField)
	Debugv(string)
	Debugvf(string, ...interface{})
	Debugvs(string, ...LogField)

	Error(string)
	Errorf(string, ...interface{})
	Errors(string, ...LogField)

	Infoq(string)
	Infoqf(string, ...interface{})
	Infoqs(string, ...LogField)
	Info(string)
	Infof(string, ...interface{})
	Infos(string, ...LogField)
	Infov(string)
	Infovf(string, ...interface{})
	Infovs(string, ...LogField)

	Warn(string)
	Warnf(string, ...interface{})
	Warns(string, ...LogField)

	StartTracing()
	StopTracing()
	Trace(string)
	Tracef(string, ...interface{})

	LogInteger(string, int) LogField
	LogGeneric(string, interface{}) LogField
	LogString(string, string) LogField
	LogTime(string, time.Time) LogField
	LogDuration(string, time.Duration) LogField

	// Used by tests only to tweak internals as needed
	TestHelper(string, interface{}) interface{}

	// Seal the interface to allow users to create a config only by embedding
	// BaseConfig.
	sealed()
}

// DocSet contains the config documentation for a specific language
type DocSet struct {
	// Use contains a string appended to the application name, when displaying
	// the help for the root command. It can be useful, for example, if a
	// positional parameter is used in the application: for example if the
	// application is named "tester" and it is going to support a URI of the
	// site to test as a parameter, this string could be set to "[website
	// address]".
	Use string

	// Short contains the short description for the program (displayed for the
	// root command)
	Short string

	// Long contains the short description for the program (displayed for the
	// root command)
	Long string

	// Example contains usage examples for the command
	Example string

	// HelpFlag contains the help string displayed in the root command help
	// for the --help help flag.
	HelpFlag string

	// CmdFlags contains the string corresponding to [flags] which is printed
	// after the command in the usage line if required.
	CmdFlags string

	// ConfigEnvMsg1 contains the first part of the localizable message for
	// the config env command
	ConfigEnvMsg1 string

	// ConfigEnvMsg2 contains the second part of the localizable message for
	// the config env command
	ConfigEnvMsg2 string

	// ConfigEnvMsg3 contains the third and final part of the localizable
	// message for the config env command
	ConfigEnvMsg3 string

	// Help points to a struct that contains the strings used in the help
	// template itself (things like "Aliases:" etc.)
	Help *HelpStrings

	// CmdLine contains the doc strings displayed in each command-line flag,
	// for the specified configuration file variable. This map is keyed by the
	// file variable name.
	CmdLine map[string]string

	// ConfigFile contains the doc strings that will be put in the
	// autogenerated configuration file before each configuration file
	// variable. This map is also keyed by the configuration file variable
	// name.
	ConfigFile map[string]string

	// Usage contains the command-specific usage information, the key is the
	// command name as defined in the command map that is passed to Execute.
	Usage map[string]*CmdHelp

	// Custom contains user-supplied localized strings
	Custom map[string]string
}

// CmdHelp contains the Cobra use/short/long/example documentation strings in a
// particular language.
type CmdHelp struct {
	// Use contains the use information for the command, if it takes arguments
	Use string
	// Short contains the short documentation for the command, typically
	// displayed in the parent command's help
	Short string
	// Long contains the long documentation for the command
	Long string
	// Example contains any examples for this command
	Example string
}

// HelpStrings contains the strings used for the various portions of the
// template.
type HelpStrings struct {
	// Usage contains the localized "Usage:" sentence
	Usage string
	// Aliases contains the localized "Aliases:" sentence
	Aliases string
	// Examples contains the localized "Examples:" sentence
	Examples string
	// AvailableCommands contains the localized "Available Commands:" sentence
	AvailableCommands string
	// Flags contains the localized "Flags:" sentence
	Flags string
	// GlobalFlags contains the localized "Global Flags:" sentence
	GlobalFlags string
	// AdditionalHelpTopics contains the localized "Additional help topics:"
	// sentence
	AdditionalHelpTopics string
	// ProvidesMoreInformationAboutACommand contains the localized "provides
	// more information about a command." sentence
	ProvidesMoreInformationAboutACommand string
}

// BaseConfigOptions can be used to set the same-named variables in a
// configuration to the specified values. DefaultLanguage will be ignored if
// empty, version strings will be assigned as-is
type BaseConfigOptions struct {
	DefaultLanguage   string
	VersionFull       string
	VersionMajor      string
	VersionMinor      string
	VersionPatchlevel string
}

// BaseConfig is FIXME:DOC
type BaseConfig struct {
	// Base commandline/config parameters users can access directly
	// ------------------------------------------------------------------
	LogLevel  *EnumValue `greenery:"|log-level|l,   .log-level,  LOGLEVEL"`
	ConfFile  string     `greenery:"|config|c,      ,            CONFIGFILE"`
	LogFile   string     `greenery:"|log-file|,     .log-file,   LOGFILE"`
	Pretty    bool       `greenery:"|pretty|,       .pretty,     PRETTY"`
	NoEnv     bool       `greenery:"|no-env|,       .no-env,     "`
	Verbosity *IntValue  `greenery:"|verbosity|v,   .verbosity,  VERBOSITY"`
	DoTrace   bool       `greenery:"|trace|hidden,  ,            TRACE"`

	// config command, must be kept in sync with doc.ConfigInitCmd
	// ------------------------------------------------------------------
	CfgForce    bool       `greenery:"config>init|force|,,"`
	CfgLocation *EnumValue `greenery:"config>init|location|,,"`

	// Values users is expected to set as part of their configuration init
	// function. Users might need to access these directly in their code
	// afterwards (for example to implement version compatibility, or to check
	// the default language for error message purposes) so these are public.
	//
	// For versions VersionFull has precedence over major/minor/patchlevel so
	// will be printed instead if set.
	// ------------------------------------------------------------------
	VersionFull       string `greenery:"||none,,"`
	VersionMajor      string `greenery:"||none,,"`
	VersionMinor      string `greenery:"||none,,"`
	VersionPatchlevel string `greenery:"||none,,"`

	// ------------------------------------------------------------------
	// Internals, which users shouldn't need, prefix with s_ to make it easier
	// to avoid collisions with user variables in case they have their
	// own. Golint will complain about these given they have underscores in
	// them, making it less likely users will use them...
	// ------------------------------------------------------------------
	s_additionalEnv   []additionalStruct
	s_appName         string
	s_args            []string
	s_cfgDir          string
	s_cl              Config
	s_cmds            map[string]*cobra.Command
	s_cobrabuf        *bytes.Buffer
	s_currentcmd      string
	s_defaultLanguage string
	s_docs            *DocSet
	s_env             map[string]string
	s_executing       bool
	s_extraParser     func(Config, map[string]interface{}) ([]string, error)
	s_extraWanted     []string
	s_filesToClose    []afero.File
	s_filesToRemove   []string
	s_fmap            map[string]Handler
	s_fs              afero.Fs
	s_inited          bool
	s_lang            string
	s_loaded          bool
	s_log             Logger
	s_processed       bool
	s_trace           Logger
	s_tracing         bool
	s_ucAppName       string
	s_usedConf        string
	s_v               *viper.Viper
	s_w               io.Writer

	s_makeStructured MakeLogger
	s_makePretty     MakeLogger
	s_makeTrace      MakeTraceLogger

	s_rootHandler    Handler
	s_configHandler  Handler
	s_versionHandler Handler
	s_preExecHandler Handler
}

// Handler is FIXME:DOC
type Handler func(Config, []string) error

// ---------------------------------------------------------------------------

// SetOptions is FIXME:DOC
func (cfg *BaseConfig) SetOptions(opts BaseConfigOptions) error {
	if cfg.s_executing {
		return fmt.Errorf("Configuration options can be changed only before executing")
	}

	if opts.DefaultLanguage != "" {
		cfg.s_defaultLanguage = opts.DefaultLanguage
	}
	cfg.VersionFull = opts.VersionFull
	cfg.VersionMajor = opts.VersionMajor
	cfg.VersionMinor = opts.VersionMinor
	cfg.VersionPatchlevel = opts.VersionPatchlevel
	return nil
}

// SetFs is FIXME:DOC
func (cfg *BaseConfig) SetFs(fs afero.Fs) {
	cfg.s_fs = fs
	cfg.s_v.SetFs(fs)
}

// GetFs is FIXME:DOC
func (cfg *BaseConfig) GetFs() afero.Fs {
	return cfg.s_fs
}

// GetCurrentCommand is FIXME:DOC doc that root is returned as ""
func (cfg *BaseConfig) GetCurrentCommand() string {
	return cfg.s_currentcmd
}

// GetDefaultLanguage is FIXME:DOC
func (cfg *BaseConfig) GetDefaultLanguage() string {
	return cfg.s_defaultLanguage
}

// RegisterExtraParse is FIXME:DOC
func (cfg *BaseConfig) RegisterExtraParse(f func(Config, map[string]interface{}) ([]string, error), a []string) {
	cfg.s_extraParser = f
	cfg.s_extraWanted = a
}

// Unmarshal is FIXME:DOC
func (cfg *BaseConfig) Unmarshal(s string, v interface{}) error {
	return cfg.s_v.UnmarshalKey(s, v)
}

// GetConfigFile FIXME:DOC
func (cfg *BaseConfig) GetConfigFile() string {
	return cfg.s_usedConf
}

// GetLogger is FIXME:DOC
func (cfg *BaseConfig) GetLogger() Logger {
	return cfg.s_log
}

// SetLoggers is FIXME:DOC doc that nil is ok and will just disable that logging
func (cfg *BaseConfig) SetLoggers(structured, pretty MakeLogger, trace MakeTraceLogger) error {
	cfg.s_makePretty = pretty
	cfg.s_makeTrace = trace
	cfg.s_makeStructured = structured

	// For now nothing to check
	return nil
}

// SetHandler is FIXME:DOC
func (cfg *BaseConfig) SetHandler(handler string, h Handler) error {
	switch handler {
	case "root":
		cfg.s_rootHandler = h
	case doc.ConfigCmd:
		cfg.s_configHandler = h
	case doc.VersionCmd:
		cfg.s_versionHandler = h
	case "pre-exec-handler":
		cfg.s_preExecHandler = h
	default:
		return fmt.Errorf("Unsupported handler %v", handler)
	}

	return nil
}

// TestHelper is used by tests to change some internals if needed
func (cfg *BaseConfig) TestHelper(task string, value interface{}) interface{} {
	switch task {
	case "set-root-args":
		cfg.s_cmds[rootCommandID].SetArgs(value.([]string))
		cfg.s_args = value.([]string)
	case "set-cfg-file":
		cfg.ConfFile = value.([]string)[0]
	case "set-log-file":
		cfg.LogFile = value.([]string)[0]
	case "set-do-trace":
		if value.([]string)[0] != "" && value.([]string)[0] == "true" {
			// Tracing in UTs does not use this code path
			cfg.DoTrace = true
		} else {
			cfg.DoTrace = false
		}
	case "get-fmap":
		return cfg.s_fmap
	case "set-fmap":
		cfg.s_fmap = value.(map[string]Handler)
	case "stack-trace-handler":
		// Used only when tracing, not exercised in UTs
		go func() {
			s := make(chan os.Signal, 1)
			signal.Notify(s, syscall.SIGQUIT)
			buf := make([]byte, 8192)
			for {
				<-s
				l := runtime.Stack(buf, true)
				cfg.Trace("=== received SIGQUIT ===")
				cfg.Tracef("Stack trace follows\n\n\n\n%s",
					buf[:l])
			}
		}()
	case "get-loggers":
		return [3]interface{}{
			cfg.s_makeStructured,
			cfg.s_makePretty,
			cfg.s_makeTrace}
	default:
		panic("Unknown task: " + task)
	}

	return nil
}

// Dump is FIXME:DOC
func (cfg *BaseConfig) Dump(icfg Config) (string, error) {
	out := []string{}

	cfg, err := getCfg(icfg)
	if err != nil {
		// Should never happen given the interface
		return "", err
	}

	if cfg.DoTrace {
		// For debugging purposes dump the actual full contents. Not exercised
		// in UTs.
		return spew.Sdump(icfg), nil
	}

	out = append(out, ` 
The following configuration values have been parsed. A selection of base
configuration values is included and displayed first.

Note that only the root commandline parameters will be parsed when invoking
this command, so commandline overrides for config/env values will not be in
effect.  

---------------------------------------------------------------------------`)

	t := reflect.TypeOf(icfg).Elem()
	v := reflect.ValueOf(icfg).Elem()
	outs := []string{}
	outb := []string{}
	for i := 0; i < t.NumField(); i++ {
		x := t.Field(i)

		// Ignore unexported fields
		r, _ := utf8.DecodeRuneInString(x.Name)
		if !unicode.IsUpper(r) {
			continue
		}

		if x.Type == basePType {
			for i2 := 0; i2 < baseType.NumField(); i2++ {
				x2 := baseType.Field(i2)

				// Ignore unexported fields
				r, _ = utf8.DecodeRuneInString(x2.Name)
				if !unicode.IsUpper(r) {
					continue
				}

				// Do not display some base fields that should not matter to
				// users.
				switch x2.Name {
				case "LogLevel":
					outb = append(outb, fmt.Sprintf("\nLogLevel: %s", cfg.LogLevel.Value))
				case "Pretty":
					continue
				case "NoEnv":
					continue
				case "Verbosity":
					outb = append(outb, fmt.Sprintf("\nVerbosity: %v", cfg.Verbosity.Value))
				case "CfgLocation":
					continue
				case "CfgForce":
					continue
				case "DoTrace":
					continue
				default:
					v2 := v.Field(i).Elem()
					field := v2.FieldByName(x2.Name)
					outb = append(outb, fmt.Sprintf("\n%s: %v", x2.Name, field.Interface()))
				}
			}

			// Add some internal fields that might be useful, these can be
			// accessed via accessors
			outb = append(outb, fmt.Sprintf("\nLoaded base,user languages (accessible via GetDocs): %s", cfg.s_lang))
			outb = append(outb, fmt.Sprintf("\nLoaded config file, if any (accessible via GetConfigFile): %s", cfg.s_usedConf))
		} else {
			field := v.FieldByName(x.Name)
			outs = append(outs, fmt.Sprintf("\n%s: %v", x.Name, field.Interface()))
		}
	}

	sort.Strings(outs)
	sort.Strings(outb)
	out = append(out, outb...)
	out = append(out, "\n")
	out = append(out, outs...)
	out = append(out, "\n---------------------------------------------------------------------------\n")
	return strings.Join(out, ""), nil
}

// NewBaseConfig is FIXME:DOC
func NewBaseConfig(appname string, fmap map[string]Handler) *BaseConfig {
	if appname == "" {
		panic("A non-empty name for the application must be set when creating a configuration")
	}

	rootCmd := &cobra.Command{}
	configCmd := &cobra.Command{}
	configDisplayCmd := &cobra.Command{}
	configEnvCmd := &cobra.Command{}
	configInitCmd := &cobra.Command{}
	versionCmd := &cobra.Command{}

	cfg := BaseConfig{
		Verbosity:    NewDefaultIntValue("Verbosity", 1, 0, 3),
		CfgLocation:  NewDefaultEnumValue("CfgLocation", "cwd", "cwd", "user", "system"),
		LogLevel:     NewDefaultEnumValue("LogLevel", "error", "debug", "info", "warn", "error"),
		VersionMajor: "0",
		VersionMinor: "0",

		s_cmds: map[string]*cobra.Command{
			rootCommandID:        rootCmd,
			doc.ConfigCmd:        configCmd,
			doc.ConfigDisplayCmd: configDisplayCmd,
			doc.ConfigEnvCmd:     configEnvCmd,
			doc.ConfigInitCmd:    configInitCmd,
			doc.VersionCmd:       versionCmd,
		},
		s_cobrabuf:        new(bytes.Buffer),
		s_defaultLanguage: "en",
		s_env:             make(map[string]string),
		s_v:               viper.New(),
		s_w:               os.Stderr,
		s_filesToClose:    make([]afero.File, 0),
		s_filesToRemove:   make([]string, 0),
		s_fmap:            fmap,
		s_appName:         appname,
		s_ucAppName:       strings.ToUpper(appname),

		s_makeStructured: BaseStructuredLogger,
		s_makePretty:     BasePrettyLogger,
		s_makeTrace:      BaseTraceLogger,
	}
	// Set up afero to make it easy to test.
	cfg.SetFs(afero.NewOsFs())

	configInitCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
		return runWrapper(cmd, &cfg, configInitCmdRunner, args)
	}

	configEnvCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
		return runWrapper(cmd, &cfg, configEnvCmdRunner, args)
	}

	configDisplayCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
		return runWrapper(cmd, &cfg, configDisplayCmdRunner, args)
	}

	versionCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
		return runWrapper(cmd, &cfg, versionCmdRunner, args)
	}

	cfg.s_cl = &cfg
	cfg.s_inited = true
	return &cfg
}

// GetDocs is FIXME:DOC
func (cfg *BaseConfig) GetDocs() (string, *DocSet) {
	return cfg.s_lang, cfg.s_docs
}

// StartTracing is FIXME:DOC Trace cannot be set via config file, only
// environment or command line, so just look at those. Done automatically if
// user passes --trace but can also be done programmatically
func (cfg *BaseConfig) StartTracing() {
	if cfg.s_tracing {
		return
	}
	cfg.s_tracing = true

	// Reuse the previous tracer if users are turning this on and off
	if cfg.s_trace == nil && cfg.s_makeTrace != nil {
		cfg.s_trace = cfg.s_makeTrace(cfg)
	}
}

// StopTracing is FIXME:DOC
func (cfg *BaseConfig) StopTracing() {
	if !cfg.s_tracing {
		return
	}
	cfg.s_tracing = false
}

// Execute is FIXME:DOC
func (cfg *BaseConfig) Execute(icfg Config, userDocList map[string]*DocSet) error {
	if !cfg.s_inited {
		return fmt.Errorf("The configuration struct passed to execute was not initialized properly")
	}

	// Save the user configuration in our base config for later use.
	cfg.s_cl = icfg

	// --trace is special, and only used during development, peek at this as
	// soon as possible to enable tracing even before the configuration is
	// fully parsed. Not supported in config files, but ok in the environment
	// so look there as well. Note either being set means turn on tracing, so
	// no need to look at one overriding the other.

	// FIXME:DOC doc this tracing is cmdline or env, either set makes it true,
	// there is no override
	if t := os.Getenv(cfg.s_ucAppName + "_TRACE"); t != "" {
		cfg.DoTrace = true
	}

	execArgs := os.Args
	if cfg.s_args != nil {
		// Testing, use the test-provided args instead of os.Args
		execArgs = cfg.s_args
	}

	for _, k := range execArgs {
		if k == "--trace" || cfg.DoTrace {
			cfg.StartTracing()
			break
		}
	}

	// Disallow some functions once we have started executing.
	cfg.s_executing = true
	rootCmd := cfg.s_cmds[rootCommandID]
	configCmd := cfg.s_cmds[doc.ConfigCmd]
	versionCmd := cfg.s_cmds[doc.VersionCmd]

	// Set up the handlers if needed
	if cfg.s_rootHandler != nil {
		// Otherwise this won't be called, the user can do their validation as
		// needed in the handler.
		rootCmd.Args = cobra.ArbitraryArgs
		rootCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
			return runWrapper(cmd, cfg, cfg.s_rootHandler, args)
		}
	} else {
		rootCmd.Args = cobra.NoArgs
	}

	if cfg.s_configHandler != nil {
		configCmd.Args = cobra.ArbitraryArgs
		configCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
			return runWrapper(cmd, cfg, cfg.s_configHandler, args)
		}
	} else {
		configCmd.Args = cobra.NoArgs
	}

	// To get a better error message
	versionCmd.Args = cobra.ArbitraryArgs
	if cfg.s_versionHandler != nil {
		versionCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
			return runWrapper(cmd, cfg, cfg.s_versionHandler, args)
		}
	}

	lenv := os.Getenv("LANG")
	// Note this will deepcopy, so defaultDoc is independent from the doclist
	defaultDoc, lang, err := getDocset(defaultDocList, lenv, cfg.s_defaultLanguage)
	if err != nil {
		// This really should not happen
		return err
	}

	userDocs, userLang, err := getDocset(userDocList, lenv, cfg.s_defaultLanguage)
	if err != nil {
		// It is valid to not have any new docs if there are no new commands
		// (although not sure how useful that is)

		if len(cfg.s_fmap) != 0 {
			// This usually means the caller did not provide a default
			// documentation or had issues in it.
			return fmt.Errorf("Cannot load the documentation: %s", err.Error())
		}
	}

	cfg.s_docs = defaultDoc
	cfg.s_lang = lenv + "," + lang + "," + userLang

	// Let's create a set of merged effective docs, by adding to baseDocs all
	// the user specified values.

	// First set the default usages
	helpCmd := getHelpCmd()
	var helpSave string
	for k := range defaultDoc.Usage {
		if candidate, ok := cfg.s_cmds[k]; ok {
			candidate.Use = defaultDoc.Usage[k].Use
			candidate.Short = defaultDoc.Usage[k].Short
			candidate.Long = defaultDoc.Usage[k].Long
			candidate.Example = defaultDoc.Usage[k].Example
		} else {
			if k == "help" {
				helpSave = defaultDoc.Usage[k].Use
				helpCmd.Use = "help " + defaultDoc.Usage[k].Use
				helpCmd.Short = defaultDoc.Usage[k].Short
				helpCmd.Long = defaultDoc.Usage[k].Long
				helpCmd.Example = defaultDoc.Usage[k].Example
			} else {
				// Should not happen
				return fmt.Errorf("Internal error, no command %s", k)
			}
		}
	}

	// Override values in an existing command if the user provided them
	rootCmd.Use = cfg.s_appName
	if userDocs.Use != "" {
		rootCmd.Use += " " + userDocs.Use
	} else {
		// Currently unused
		if defaultDoc.Use != "" {
			rootCmd.Use += " " + defaultDoc.Use
		}
	}

	if userDocs.Short != "" {
		rootCmd.Short = userDocs.Short
	} else {
		rootCmd.Short = defaultDoc.Short
	}

	if userDocs.Long != "" {
		rootCmd.Long = userDocs.Long
	} else {
		rootCmd.Long = defaultDoc.Long
	}

	if userDocs.Example != "" {
		rootCmd.Example = userDocs.Example
	} else {
		rootCmd.Example = defaultDoc.Example
	}

	if userDocs.HelpFlag != "" {
		rootCmd.PersistentFlags().Bool("help", false, userDocs.HelpFlag)
	} else {
		rootCmd.PersistentFlags().Bool("help", false, defaultDoc.HelpFlag)
	}
	rootCmd.SetHelpCommand(helpCmd)

	for k := range userDocs.Usage {
		if candidate, ok := cfg.s_cmds[k]; ok {
			if k == rootCommandID {
				return fmt.Errorf("Please use the root command section to specify root command options, not the usage one")
			}

			if userDocs.Usage[k].Use != "" {
				candidate.Use = userDocs.Usage[k].Use
			}

			if userDocs.Usage[k].Short != "" {
				candidate.Short = userDocs.Usage[k].Short
			}

			if userDocs.Usage[k].Long != "" {
				candidate.Long = userDocs.Usage[k].Long
			}

			if userDocs.Usage[k].Example != "" {
				candidate.Example = userDocs.Usage[k].Example
			}
		} else {
			// Help is special, since it's internal to cobra, so for
			// overriding it will be on this side of the if.
			if k == "help" {
				if userDocs.Usage[k].Use != "" {
					helpSave = userDocs.Usage[k].Use
					helpCmd.Use = "help " + userDocs.Usage[k].Use
				}

				if userDocs.Usage[k].Short != "" {
					helpCmd.Short = userDocs.Usage[k].Short
				}

				if userDocs.Usage[k].Long != "" {
					helpCmd.Long = userDocs.Usage[k].Long
				}

				if userDocs.Usage[k].Example != "" {
					helpCmd.Example = userDocs.Usage[k].Example
				}
			}

			// If not help it would be a user command, which is dealt with
			// below.
		}
	}

	// CmdLine and ConfigFile, if the user has overrides for default docs,
	// they will take precedence
	for k, v := range userDocs.CmdLine {
		defaultDoc.CmdLine[k] = v
	}

	for k, v := range userDocs.ConfigFile {
		defaultDoc.ConfigFile[k] = v
	}

	// Default docs have no custom, so can just assign directly
	defaultDoc.Custom = userDocs.Custom

	t, err := template.New("helpMsg").Parse(usageTemplate)
	if err != nil {
		// Should not happen
		return err
	}

	usagePreprocess := usageStruct{
		OpenBrace:  "{{",
		CloseBrace: "}}",
		Command:    helpSave,
	}

	usagePreprocess.HelpStrings = defaultDoc.Help
	// Allow users to override only some strings
	if userDocs.Help != nil {
		if userDocs.Help.Usage != "" {
			usagePreprocess.HelpStrings.Usage = userDocs.Help.Usage
		}
		if userDocs.Help.Aliases != "" {
			usagePreprocess.HelpStrings.Aliases = userDocs.Help.Aliases
		}
		if userDocs.Help.Examples != "" {
			usagePreprocess.HelpStrings.Examples = userDocs.Help.Examples
		}
		if userDocs.Help.AvailableCommands != "" {
			usagePreprocess.HelpStrings.AvailableCommands = userDocs.Help.AvailableCommands
		}
		if userDocs.Help.Flags != "" {
			usagePreprocess.HelpStrings.Flags = userDocs.Help.Flags
		}
		if userDocs.Help.GlobalFlags != "" {
			usagePreprocess.HelpStrings.GlobalFlags = userDocs.Help.GlobalFlags
		}
		if userDocs.Help.AdditionalHelpTopics != "" {
			usagePreprocess.HelpStrings.AdditionalHelpTopics = userDocs.Help.AdditionalHelpTopics
		}
		if userDocs.Help.ProvidesMoreInformationAboutACommand != "" {
			usagePreprocess.HelpStrings.ProvidesMoreInformationAboutACommand = userDocs.Help.ProvidesMoreInformationAboutACommand
		}
	}

	// Other misc strings
	if userDocs.ConfigEnvMsg1 != "" {
		defaultDoc.ConfigEnvMsg1 = userDocs.ConfigEnvMsg1
	}
	if userDocs.ConfigEnvMsg2 != "" {
		defaultDoc.ConfigEnvMsg2 = userDocs.ConfigEnvMsg2
	}
	if userDocs.ConfigEnvMsg3 != "" {
		defaultDoc.ConfigEnvMsg3 = userDocs.ConfigEnvMsg3
	}

	var b bytes.Buffer
	err = t.Execute(&b, usagePreprocess)
	if err != nil {
		// Should not happen
		return err
	}
	cfg.s_cmds[rootCommandID].SetUsageTemplate(b.String())

	seenFields := map[string]bool{}
	cfg.s_additionalEnv, err = createBindings(cfg.TraceSkipf, cfg, cfg.s_v, cfg.s_cmds, cfg.s_env, defaultDoc.CmdLine, cfg.s_ucAppName, seenFields)
	if err != nil {
		// Should not happen
		return err
	}

	if _, err = getCfg(icfg); err != nil {
		// Should not happen due to the sealed interface
		return fmt.Errorf("Invalid configuration struct passed to Execute, it must embed BaseConfiguration")
	}

	var binds = []struct{ p, c string }{}
	// First the internal commands
	for k, v := range cfg.s_cmds {
		if k == rootCommandID {
			continue
		}

		parent, cname := getParentChild(k)

		// Provide a default if the doc didn't have any.
		if v.Use == "" {
			v.Use = cname
		} else {
			v.Use = cname + " " + v.Use
		}
		binds = append(binds, struct{ p, c string }{parent, k})
	}

	// Then the user commands. Note internal commands are not allowed to be
	// overridden, users must use SetHandler for those.
	for k, v := range cfg.s_fmap {
		if k == rootCommandID ||
			k == doc.ConfigCmd ||
			k == doc.VersionCmd ||
			k == doc.ConfigInitCmd ||
			k == doc.ConfigDisplayCmd ||
			k == doc.ConfigEnvCmd {
			if k == rootCommandID {
				k = "root"
			}
			return fmt.Errorf("Overriding of the %s command is not permitted, please use cfg.SetHandler to set your desired handler", k)
		}

		lk := len(k)
		argsok := false
		cfg.Tracef("user command %s", k)
		if k[lk-1:] == sepCmdArgs {
			cfg.Tracef("has args")
			k = k[:lk-1]
			argsok = true
		}

		// Need to capture for the function
		v := v
		parent, cname := getParentChild(k)

		newCmd := &cobra.Command{}
		if argsok {
			newCmd.Args = cobra.ArbitraryArgs
		} else {
			newCmd.Args = cobra.NoArgs
		}

		docEntry, ok := userDocs.Usage[k]
		if !ok {
			return fmt.Errorf("Cannot find a Usage entry in the docs for command %s", k)
		}

		if docEntry.Use == "" {
			newCmd.Use = cname
		} else {
			newCmd.Use = cname + " " + docEntry.Use
		}

		newCmd.Short = docEntry.Short
		newCmd.Long = docEntry.Long
		newCmd.Example = docEntry.Example
		cfg.Tracef("Setting %v to %v", k, v)
		if v != nil {
			newCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
				return runWrapper(cmd, cfg, v, args)
			}
		} else {
			cfg.Tracef("Was nil")
			if argsok {
				cfg.Tracef("argsok")
				return fmt.Errorf("command %s supports arguments but has a nil handler", k)
			}
			cfg.Tracef("noargsok")

			newCmd.RunE = func(cmd *cobra.Command, args []string) (err error) {
				return runWrapper(cmd, cfg, func(Config, []string) error {
					return cmd.Help()
				}, args)
			}
		}
		cfg.s_cmds[k] = newCmd
		binds = append(binds, struct{ p, c string }{parent, k})
	}

	// Binds should be done after all the commands are created so users don't
	// have to keep their additional cmds list in order.
	for _, b := range binds {
		pcmd, ok := cfg.s_cmds[b.p]
		if !ok {
			return fmt.Errorf("Command %s, needed as a parent of %s, was not defined", b.p, b.c)
		}
		pcmd.AddCommand(cfg.s_cmds[b.c])
	}

	additional, err := createBindings(cfg.TraceSkipf, icfg, cfg.s_v, cfg.s_cmds, cfg.s_env, defaultDoc.CmdLine, cfg.s_ucAppName, seenFields)
	if err != nil {
		return err
	}

	// The base configuration might already have some additionalEnv commands
	// in s_additionalEnv, add to the list any user ones.
	cfg.s_additionalEnv = append(cfg.s_additionalEnv, additional...)

	// We are giving errors back to the user to do as they see fit, so do not
	// double-print them via cobra.
	rootCmd.SilenceErrors = true

	// This is required because cobra does not expose [flags] but hardcodes it
	// both for help and usage. First make sure we save if help was requested
	// by the user.
	helpRequested := false
	defaultHelpFunc := rootCmd.HelpFunc()
	rootCmd.SetHelpFunc(func(cmd *cobra.Command, args []string) {
		helpRequested = true
		defaultHelpFunc(cmd, args)
	})

	rootCmd.SetOutput(cfg.s_cobrabuf)
	rootCmd.SilenceUsage = true
	execCmd, err := rootCmd.ExecuteC()

	// Now make sure we massage any help/usage output so we can localize
	// [flags] as needed.
	if err != nil {
		// Cobra seems to use a temporary output buffer in UsageString, so we
		// can't get to it same way we do for HelpFunc below, given this
		// by default we disable usage and instead print it out ourselves in
		// case of errors.
		usage := execCmd.UsageString()
		fl := fixMagicTemplate(usage, userDocs.CmdFlags, defaultDoc.CmdFlags)
		for _, s := range fl {
			fmt.Fprintf(os.Stderr, "%s\n", s)
		}
	} else {
		if helpRequested {
			// If help was requested, we also have to massage the buffer
			// before printing it out (to stdout)
			fl := fixMagicTemplate(cfg.s_cobrabuf.String(), userDocs.CmdFlags, defaultDoc.CmdFlags)
			for _, s := range fl {
				fmt.Printf("%s\n", s)
			}
		} else {
			// If no help was requested assume this was a cobra error and just
			// print it out.
			_, err = io.Copy(os.Stderr, cfg.s_cobrabuf)
			if err != nil {
				// Should not happen
				return err
			}
		}
	}
	return err
}

// Cleanup is FIXME:DOC
func (cfg *BaseConfig) Cleanup() {
	for _, f := range cfg.s_filesToClose {
		if err := f.Close(); err != nil {
			cfg.Errorf("Cannot close %v (%s)\n", f.Name(), err.Error())
		}
	}

	for _, f := range cfg.s_filesToRemove {
		if err := cfg.s_fs.Remove(f); err != nil {
			cfg.Errorf("Cannot remove %v (%s)\n", f, err.Error())
		}
	}

	cfg.Debug("Program end")
	if cfg.s_log != nil {
		_ = cfg.s_log.Sync()
	}

	cfg.Trace("Program end")
	if cfg.s_trace != nil {
		_ = cfg.s_trace.Sync()
	}

}

// Debugq is used to debug log to the current logger with verbosity 1
func (cfg *BaseConfig) Debugq(s string) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 1 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(s)
	}
}

// Debugqf is used to sprintf debug log to the current logger with verbosity 1
func (cfg *BaseConfig) Debugqf(format string, vals ...interface{}) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 1 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(fmt.Sprintf(format, vals...))
	}
}

// Debugqs is used to structured debug log to the current logger with verbosity 1
func (cfg *BaseConfig) Debugqs(s string, vals ...LogField) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 1 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(s, vals...)
	}
}

// Debug is used to debug log to the current logger with verbosity 2 (typical)
func (cfg *BaseConfig) Debug(s string) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 2 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(s)
	}
}

// Debugf is used to sprintf debug log to the current logger with verbosity 2
// (typical)
func (cfg *BaseConfig) Debugf(format string, vals ...interface{}) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 2 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(fmt.Sprintf(format, vals...))
	}
}

// Debugs is used to structured debug log to the current logger with verbosity 2
// (typical)
func (cfg *BaseConfig) Debugs(s string, vals ...LogField) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 2 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(s, vals...)
	}
}

// Debugv is used to debug log to the current logger with verbosity 3
func (cfg *BaseConfig) Debugv(s string) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 3 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(s)
	}
}

// Debugvf is used to sprintf debug log to the current logger with verbosity 3
func (cfg *BaseConfig) Debugvf(format string, vals ...interface{}) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 3 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(fmt.Sprintf(format, vals...))
	}
}

// Debugvs is used to structured debug log to the current logger with verbosity 3
func (cfg *BaseConfig) Debugvs(s string, vals ...LogField) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 3 <= cfg.Verbosity.Value {
		cfg.s_log.DebugStructured(s, vals...)
	}
}

// ---------------------------------------------------------------------------

// Infoq is used to info log to the current logger with verbosity 1
func (cfg *BaseConfig) Infoq(s string) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 1 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(s)
	}
}

// Infoqf is used to sprintf info log to the current logger with verbosity 1
func (cfg *BaseConfig) Infoqf(format string, vals ...interface{}) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 1 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(fmt.Sprintf(format, vals...))
	}
}

// Infoqs is used to structured info log to the current logger with verbosity 1
func (cfg *BaseConfig) Infoqs(s string, vals ...LogField) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 1 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(s, vals...)
	}
}

// Info is used to info log to the current logger with verbosity 2 (typical)
func (cfg *BaseConfig) Info(s string) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 2 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(s)
	}
}

// Infof is used to sprintf info log to the current logger with verbosity 2
// (typical)
func (cfg *BaseConfig) Infof(format string, vals ...interface{}) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 2 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(fmt.Sprintf(format, vals...))
	}
}

// Infos is used to structured info log to the current logger with verbosity 2
// (typical)
func (cfg *BaseConfig) Infos(s string, vals ...LogField) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 2 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(s, vals...)
	}
}

// Infov is used to info log to the current logger with verbosity 3
func (cfg *BaseConfig) Infov(s string) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 3 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(s)
	}
}

// Infovf is used to sprintf info log to the current logger with verbosity 3
func (cfg *BaseConfig) Infovf(format string, vals ...interface{}) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 3 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(fmt.Sprintf(format, vals...))
	}
}

// Infovs is used to structured info log to the current logger with verbosity 3
func (cfg *BaseConfig) Infovs(s string, vals ...LogField) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 && 3 <= cfg.Verbosity.Value {
		cfg.s_log.InfoStructured(s, vals...)
	}
}

// ---------------------------------------------------------------------------

// Warn is used to warn log to the current logger, warnings are always logged
// unless v is 0, so no need to have custom selectable verbosity
func (cfg *BaseConfig) Warn(s string) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 {
		cfg.s_log.WarnStructured(s)
	}
}

// Warnf is used to sprintf warn log to the current logger, warnings are
// always logged unless v is 0, so no need to have custom selectable verbosity
func (cfg *BaseConfig) Warnf(format string, vals ...interface{}) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 {
		cfg.s_log.WarnStructured(fmt.Sprintf(format, vals...))
	}
}

// Warns is used to structured warn log to the current logger, warnings are
// always logged unless v is 0, so no need to have custom selectable verbosity
func (cfg *BaseConfig) Warns(s string, vals ...LogField) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 {
		cfg.s_log.WarnStructured(s, vals...)
	}
}

// ---------------------------------------------------------------------------

// Error is used to error log to the current logger, errorings are always logged
// unless v is 0, so no need to have custom selectable verbosity
func (cfg *BaseConfig) Error(s string) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 {
		cfg.s_log.ErrorStructured(s)
	}
}

// Errorf is used to sprintf error log to the current logger, errorings are
// always logged unless v is 0, so no need to have custom selectable verbosity
func (cfg *BaseConfig) Errorf(format string, vals ...interface{}) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 {
		cfg.s_log.ErrorStructured(fmt.Sprintf(format, vals...))
	}
}

// Errors is used to structured error log to the current logger, errorings are
// always logged unless v is 0, so no need to have custom selectable verbosity
func (cfg *BaseConfig) Errors(s string, vals ...LogField) {
	if cfg.s_log != nil && cfg.Verbosity.Value != 0 {
		cfg.s_log.ErrorStructured(s, vals...)
	}
}

// ---------------------------------------------------------------------------
// The trace logger does not support structured logging, only pretty console
// logging, so no need to have Traces

// Trace is used to debug log to the trace logger, this is a separate stderr
// non-redirectable / non-configurable logger
func (cfg *BaseConfig) Trace(s string) {
	if cfg.s_tracing && cfg.s_trace != nil {
		cfg.s_trace.DebugStructured(s)
	}
}

// Tracef is used to sprintf debug log to the trace logger, this is a separate
// stderr non-redirectable / non-configurable logger
func (cfg *BaseConfig) Tracef(format string, vals ...interface{}) {
	if cfg.s_tracing && cfg.s_trace != nil {
		cfg.s_trace.DebugStructured(fmt.Sprintf(format, vals...))
	}
}

// TraceSkipf will tracef log but skipping additional frames in case .Trace is
// being passed around as a function.
func (cfg *BaseConfig) TraceSkipf(skip int, format string, vals ...interface{}) {
	if cfg.s_tracing && cfg.s_trace != nil {
		cfg.s_trace.DebugSkip(skip, fmt.Sprintf(format, vals...))
	}
}

// LogInteger is FIXME:DOC
func (cfg *BaseConfig) LogInteger(s string, value int) LogField {
	if cfg.s_log == nil {
		return LogField{}
	}
	return cfg.s_log.LogInteger(s, value)
}

// LogTime is FIXME:DOC
func (cfg *BaseConfig) LogTime(s string, value time.Time) LogField {
	if cfg.s_log == nil {
		return LogField{}
	}
	return cfg.s_log.LogTime(s, value)
}

// LogDuration is FIXME:DOC
func (cfg *BaseConfig) LogDuration(s string, value time.Duration) LogField {
	if cfg.s_log == nil {
		return LogField{}
	}
	return cfg.s_log.LogDuration(s, value)
}

// LogString is FIXME:DOC
func (cfg *BaseConfig) LogString(s string, value string) LogField {
	if cfg.s_log == nil {
		return LogField{}
	}
	return cfg.s_log.LogString(s, value)
}

// LogGeneric is FIXME:DOC
func (cfg *BaseConfig) LogGeneric(s string, value interface{}) LogField {
	if cfg.s_log == nil {
		return LogField{}
	}
	return cfg.s_log.LogGeneric(s, value)
}

// --------------------------------
func (cfg *BaseConfig) sealed() {}
